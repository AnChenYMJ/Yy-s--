





void study()
{
	//设置光标
	if (1)
	{
		/*
			1.设置光标位置：
				功能：使画面更美观简洁
				要点：
						1.printf是在光标位置开始输出打印
						2.刚开始光标在最左上侧，打印了之后，光标自动在打印完的内容后面一个（自行观测）
						3.实际工作中可能一辈子用不到
						3.用一个API函数 SetConsoleCursorPosition();	（windows.h）头文件 
								1.参1：所在窗口句柄，参2：一个结构体（系统定义好了）
						4.获取句柄：GetStdHandle(STD_OUTPUT_HANDLE) 
								1.GetStdHandle		获取系统句柄
								2.STD_OUTPUT_HANDLE 则代表命令行	
						5.结构体：
								1.成员为：列 、行（即坐标的 x  y：这是赋值时的顺序） 
								2.从0行0列开始，即类似下标  0,0
		*/
	}
	//游戏界面输出(游戏界面显示的框)
	if (2)
	{
		/*
			流程：
				1.printf 结合 GotXY 打印‘*’ 来显示界面上方的游戏名
				2.用\t 来填充对齐（\t 默认8个空格，在控制台）
				3.将打印 游戏名 的代码封装到 Head函数中

				4.定义几个宏，来代表框的长宽，内部分割线的点
				5.打印框，用两个for循环，且要用GotXY指定光标位置（第一层循环内） 否则无法正常打印
				6.第二层循环内判断并打印 组成框的特殊字符上网搜，有些不支持，运行会报错
				7.if判断的条件别搞错，且else中，要用空格填补框的内部（否则不成框，而是遍历打印字符了），一个字符对应两个空格
			补充：
				1.system("pause>0");	//让命令行结尾的一大串提示不显示
				2.右击项目--属性--链接器--系统--子系统（改为未设置，即可永不提示那一大串信息）
		*/	
	}
	//左右侧小框内的提示信息
	if (3)
	{
		/*
			补充：
				1.要有一个背景数组（表示方块的移动范围）
				
			流程：
				1.定义一个背景数组（方块移动的范围，框当作墙，与空白部分区分来）
				2.在画框的时候，就把对应x y 的框定一个值，比如1 这样1的位置就代表墙 空白部分的数组x y 定义成 0 代表空白部分
				3.两个函数（左右），利用printf 结合 GotXY 来打印提示信息
				
		*/
	}
	//方块的生成
	if (4)
	{
		/*
			补充：
				1.关于这块的算法，网上有很多
				2.用0~6的随机数，每个数字对应一种方块，随机产生即可
				3.rand();	//头文件：stdlib 且需要种子（触发值） 产生随机数，一般用系统时间，这样不会重复
				4.种子：srand((unsigned int)time(NULL));	//用当前系统时间作为随机数种子  需要 time.h 头文件  种一次就够了，就可以一直调用rand
						srand需要unsigned int的参数，而time的返回值是 time_t 所以需要强转
				5.此次算法比win32的俄罗斯方块算法更加灵活

			讲解：
				1.游戏区的方块，即黑色的未落地方块（可移动），白色的落地方块
				2.next 方块：待游戏区方块落地后，产生新方块，而新产生的则是右侧已提示过的方块
				3.但是游戏一开始，初始状态，游戏区的方块是没有对应的next方块的，所以比较特殊（初始化即可）
				4.初始化，游戏一开始，给游戏区、提示区各自设定一个方块、然后就按照有规则生成方块即可
				5.方块有规则生成：方块落地，新产生方块为提示区方块

			流程：
				1.游戏初始化方块：
						1.写一个函数，内部初始化游戏区方块、next方块
						2.初始化，就是用rand随机数，0~6 各自代表不同的方块
						3.主函数开头种种子 srand，种一次，rand就可以随便用了
				2.方块有规则生成：
						
				3.方块生成时的初始位置及状态：
						1.方块在生成时的位置,要根据对应方块是什么来决定，不同的方块都选定了一个固定小格来作为它的中心
								比如正方形规定，右下角的小格为中心，那么生成时，相对于顶部的框，是在第2行，即 g_cHANG == 2 而列则是调整水平线上它生成的位置
								而长条则只有1行，其它的都是2行
						2..方块初始状态设置（即以哪种旋转的角度出现）每次旋转90度，故有4种状态，对应 0 1 2 3
				4.提示区方块生成打印（next）：
						1.先定义好变量，来规定next方块打印的位置（方便后续改动与调用逻辑）
						2.判断next方块是哪种方块,然后在提示区打印出来（next）
								用switch判断g_cNextSqure 是哪种方块
						3.残留问题，即重新生成next方块时，新的覆盖旧的，旧的还留着，导致打印的图形是不认识的
								每次执行前用空格覆盖掉旧的即可，打印空格覆盖（打印空格位置就是方块打印的那个范围）
				5.游戏区初始方块生成打印：（接上一个笔记）（写位置时，参考老师的图，会相当方便，一目了然）
					1.定义一个带参函数
					2.用switch 先判断是哪种类型方块
					3.然后具体的类型的case下，再switch判断是哪种状态（旋转状态）
							1.不同状态也要写，即生成时的状态也要随机
					4.在旋转状态下的case中，打印方块（注意方块占2字符，行列要注意大小，直接使用g_cHANG、g_cLIE，在InitState中已经给各类型定义好游戏区方块中心点的生成位置了）
							1.注意，长条方块已经在InitState函数中用if进行单独处理了，此处可以直接使用g_cHANG、g_cLIE 不必担心长条只有一列
							2.方块一定要对齐，不能出现半格的情况，否则移动会出问题（方块以2字符为单位）
					5.此种方法代码多，但相当简单暴力，灵活好用
				补充：
					1.挨个把不同方块的不同状态的，初始生成给打印，注意位置
					2.还有就是随机生成的方块6会把g_cHANG 改为1，其它的都是2，且由InitState控制
							所以改变switch参数测试时，会出现长条或其它方块上/下移，原因是，随机生成的数字，经过InitState，可能是长条或普通方块
							比如我们用switch（6）测试，结果长条下移了，因为随机生成的数字不是6，且经过了InitState，g_cHANG不是1，而是2
							不用改变什么，这是很正常的，程序正常运行时，判断条件不是常量，而是全局变量，会与随机生成的数字对应的方块吻合
		*/
	}
	//方块运动
	if (5)
	{
		/*
			
			6.方块运动：（目前还不太流畅，因为Sleep间隔长，后续会有改动）
					1.方块下落
							1.raw("  ");		//更新前，空格清除旧方块图形
							2.g_cHANG++; y轴自加即可，生成方块时统一使用了它
							3.Draw("□");	更新方块位置，哪种方块生成时已经确定好了
							4.上述代码封装成函数
							5.循环中调用函数，用Sleep函数实现控制方块下落速度 （首字母大写）
					2.方块左/右移动
							1.函数内部逻辑与 下落 类似
							2.将g_cHANG++; 替换成 g_cLIE++/-- 方块中心点在X轴的移动（方块按照中心点生成打印的）
					3.按键输入并判断
							1.按键输入：用一个异步函数（scanf、getchar、gets等都是同步阻塞的，执行了就一直等到输入才能往下继续）
									GetAsyncKeyState(),返回值：无输入返回0，有输入非0，参数去查，有宏定义哪些按键
									还有一些定义，就是按键状态的，连续按下、按下响应、抬起响应等，QT学过
							2.用多个if来判断是哪个按键输入（不用else if ，因为只能执行检测一次，多个if能同时检测到）
									多个if会影响效率（大代码量），本次不影响，代码多就需要优化了
					4.方块变形：
							1.原理：改变方块的旋转状态标志变量即可 g_cState
							2.封装变形函数：
									1.要先清除旧方块图形 调用此前写好的Draw函数
									2.让g_cState 在0~3 之间顺序变化（两种方式）
							3.变形函数在按键输入里的 ↑ 键的判断下调用即可	
		*/
	}
	//移动条件限制	(1.边界 2.变形)
	if (6)
	{
		/*
			7.移动条件限制（比如不能超过墙，到底部后固定）
					1.边界判断封装函数：
							1.三个参数，参1：旋转状态，参2、3：中心点坐标
							2.双层switch，外层：游戏区的哪种方块，内层：每种方块的哪种旋转状态
							3.内层下的每种状态的case：以中心点为基准（两个全局变量）判断方块是否触碰到边界
							4.边界在背景数组里定义成了1（二维数组），所以判断方块的小格所在位置的对应背景元素是否为1，就知道边界触碰与否
							5.碰到后，函数返回false
							6.每一个方块的每一个状态都要写判断
							7.方块到底变成‘墙’，如果少了小格子可能出问题，方块变成的‘墙’可能碰到被省略的小格子
					2.在按键输入中，移动键调用边界判断函数
							注意，此时传参，要传中心点下一步移动的坐标（相当于预判，不能碰上了才不给通过）、
							特殊：down 在down函数中进行判断更好（有其他方式）
			8.变形条件限制
					1.方块在特殊位置，因为转变方块形状，转变后的方块可能与墙或落地方块重合，所以做一个处理，变形后向左或向右、向下移动，移动后还是重合则不进行变形
					2.传参时，是进行预判（按键输入KeyState里调用）
					3.有三种情况，向左、向右、向下，其中长条因为中心点左右不对称，所以竖着变横，左侧会重合，要向右移动两格
					4.注意，变形后如果要移动，得要清理原来位置的图形，在Canchange函数中我已经写好了
					5.本案例是老师提供的方案，不是唯一，有bug可执行想然后修改
		*/
	}
	//方块到底部了，生成新方块
	if (7)
	{
		/*
			生成新方块：
					1.在Down中进行到底部的判断
					2.到底部了，切换成按照next区的顺序生成方块（调用NewSqure），然后调用Draw("□")打印
					3.然后跟着调用DrawNextSqure，更新打印next区的方块
					注意：由于主函数中调用了一次Draw打印初始方块，所以循环中立马调用Down下落的话，看起来就像是从第2行开始打印的一样
						不是的，是因为俩函数执行靠得太近，刚生成就立马下落了一格，看起来就像是第2行开始的一样
					解决：把Sleep放到循环开头即可
			方块停住：
					1.依旧在Down中进行到底部的判断
					2.让方块到底停住之后，变色，与可移动的区分开
					3.让方块变成边界一样的‘墙’，使方块能堆积（此过程需要判断方块的种类、旋转状态）
					4.第3步封装成单独的函数，调用即可
							双层switch，让每种方块的每种状态，都能变成‘墙’，（方块位置的背景数组变成1）
					5.Down中底部处理，方块停住，变色，堆积，都要在NewSqure之前完成（因为NewSqure会改变全局变量，导致操作对象改变）		
		*/
	}
	//消行的范围与得分
	if (8)
	{
		/*
			消行范围：
				1.本此案例的方法是：方块落地后，以此方块的最高、最低行为范围，来判断这几行是否满了
				2.其它的方案有：游戏区不断刷新判断之类的，可以自己想办法
				3.本次方法，不同的方块的不同形状的范围是不一样的，一些方块范围有重合，请对照方块表就知道了
			消行判断：
				1.判断具体的的那行，是否满了，用一个函数来判断，满了返回true
				2.然后循环来判断范围内的那几行
			消行得分：
				1.在Down中调用Score
				2.disappear函数消行，请分清光标位置是否准确，否则消除的是别的行
		
		*/
	}
	//消行后下落，显示分数
	if (9)
	{
		//大体三个步骤，在Fall函数中
		//1.数组向下赋值
		//2.画新方快
		//3.前一个位置去残留

		//分数计算根据自己喜好来修改整体代码然后计算
		//显示时也可以做一套算法让分数居中显示
	}
	//方块下落时，左右移动变得更敏捷丝滑（时间差）
	if (10)
	{
		//之前写的程序，下落时左右平移是每下落一次才平移一次，显得很僵硬，最多45度下落，不仅平移，还有其他按键同理
		//解决方法是：控制时间差，让按键判断能在一次下落间 多次执行
		//二者时间差就能让操作更流畅，这个思想很好用，操作明显更丝滑流畅
		//↓键的加速也是按照这个倍率，也可以加代码让↓键加速单独控制时间差倍率
	}
	//Game Over 控制
	if (11)
	{
		//用一个函数来判断是否结束了游戏
		//我个人加了个变量，为Game Over的独有控制变量

		//开始新游戏，案件判断多一个F2，然后调用准备函数 Init 就可以开始新游戏了
	}
	//控制速度
	if (12)
	{
		//让速度可控，我们控制按键与下落的时间差时，采用变量即可
		// 可自行设置速度级别，显示速度等信息
	}
	//最后的BUG
	if (13)
	{
		//按键按着不放，比如键盘右键，按住就一直向右移动，甚至抬起时也有反应，不能精准操作
		//原因是，检测按键时未指定按键扫描方式，默认按下，按住，抬起，扫描时间一到，这几种情况都当做触发被扫描
		//解决方案，检测按键时，& 0x01 就是指定它按下时(按下、按住)才生效，可自行上MSDN查阅其它触发方式
	}
}